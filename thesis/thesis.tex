%Erzeugt mit dem LaTeX-Generator: http://latex.sehnot.de

%Schriftgröße, Layout, Papierformat, Art des Dokumentes
\documentclass[12pt,oneside,a4paper]{scrbook}

%Einstellungen der Seitenränder
\usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,includeheadfoot]{geometry}

%neue Rechtschreibung
%\usepackage[ngerman]{babel}

%Umlaute ermöglichen
% \usepackage{fontspec}
% \setromanfont{TeX Gyre Pagella}

% \usepackage[math-style=iso]{unicode-math}
% \setmathfont{Asana Math}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[utf8x]{inputenc}
\usepackage{url}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{amsthm}
\usepackage[official]{eurosym}
\usepackage{setspace}
\newtheorem{definition}{Definition}
\newtheorem{satz}{Theorem}
\theoremstyle{definition}
%Zitieren
\usepackage[longnamesfirst, authoryear]{natbib}
\usepackage{minted}
\usepackage{booktabs}



%Kopf- und Fußzeile
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

%Kopfzeile rechts bzw. außen
\fancyhead[R]{\nouppercase{\leftmark}}
%Linie oben
\renewcommand{\headrulewidth}{0.5pt}

%Fußzeile links bzw. innen
\fancyfoot[L]{Units of Measure - a Scala Macro System}
%Fußzeile rechts bzw. außen
\fancyfoot[R]{\thepage}
%Linie unten
\renewcommand{\footrulewidth}{0.5pt}

\clubpenalty = 50000
\widowpenalty = 50000




\title{Units of Measure - a Scala Macro System}
\author{Julian Schrittwieser}
\date{\today}

\begin{document}


\begin{titlepage}

\begin{center}


% Upper part of the page
\includegraphics[width=0.4\textwidth]{tu-logo.png}\\[3cm]


\textsc{\Large Software \& Information Engineering}\\[0.5cm]


% Title
\HRule \\[0.8cm]
{ \huge \bfseries Units of Measure}\\[0.4cm]
\Large A Scala Macro System

\HRule \\[1.5cm]

\vfill


% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Julian \textsc{Schrittwieser}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Advisor:} \\
Univ.-Prof. Dr. Jens \textsc{Knoop}
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large Februar 12th, 2013}

\end{center}

\end{titlepage}

\pagenumbering{roman} % Roman numerals, other styles possible: http://www.image.ufl.edu/help/latex/intext.shtml
\setcounter{page}{2}

% \onehalfspacing
\chapter*{Preface}

Ipsum Lorem
\\ \\
Vienna, February 12th, 2010  \hfill Julian Schrittwieser

\singlespacing
\tableofcontents
%\onehalfspacing

\chapter{Introduction}
\pagenumbering{arabic} % Roman numerals
\setcounter{page}{1}
\section{Motivation}

\section{Nomenclature}
Throughout this paper, I use \emph{Measure} to refer to a number annotated with it's corresponding unit. The exact implementation of this annotation depends on the context, some libraries use static type informations, others fields in an object.

\section{Source Code}
The source code for all benchmarks mentioned can be found on GitHub: \url{https://github.com/Mononofu/Units-of-Measure/tree/master/thesis/benchmarks}. This same repository also contains the source for this document (\url{https://github.com/Mononofu/Units-of-Measure/tree/master/thesis}) as well as the implementation of the Units of Measurement system in Scala (\url{https://github.com/Mononofu/Units-of-Measure}).

\chapter{Related Work}

In principle, there are two distinct ways to implement units of measurement in a programming language: Either statically as part of the type system, or dynamically with objects that know their own unit. Each approach has its own merits and disadvantages, so I examine a few existing implementations in common languages before creating my own solution.

\section{Dynamic Systems}

Some programming languages do not give their users much choice, because they either completely lack static type systems (dynamic languages like Python or Ruby) or their type system is not sophisticated enough for a units of measurement library. In general, those dynamic systems allow access to unit information at runtime but in turn pay a heavy performance price: Each number is stored as a full blown object (see figure \ref{code:naive_java_measure}), not as a simple primitive like a normal number. Thus, all calculations incur additional memory lookups and values take additional space.

\begin{figure}
\begin{minted}{java}
class Measure<T extends java.lang.Number> {
  T      value;
  Unit   unit;
}
\end{minted}
\caption{A naive implementation of a number annotated with its unit in Java. Actual size depends on the number used, but at least 8 bytes are used by the object itself, and further 4/8 bytes (32/64 bit system, resp.) are needed for the reference to the unit.}
\label{code:naive_java_measure}
\end{figure}



\subsection{Java - JScience}

Java has a standardized Units of Measurement API \citep{Units13} with several implementations, both open source and commercial. I will focus on JScience here \citep{Dautelle11}. In addition to support for physical units, JScience also contains libraries for simple mathematical functions, currencies and a linear algebra module. Here, I only focus on parts pertaining to Units of Measurement.

JScience represents Measures using the class \emph{Amount}, but users are free to create their own implementations of \emph{Measurable}. Measures are created with a flexible static helper function (\emph{valueOf}) from a range of different inputs. For details, see the short usage example below in Figure \ref{code:jscience_example}. Essentially, \emph{Amount} is a wrapper class that tags a number with its corresponding unit - as shown in \ref{code:naive_java_measure} - and provides a set of helper and conversion functions.

\begin{figure}
\begin{minted}{java}
Amount<Mass> m0            = Amount.valueOf(100, POUND);
Amount<ElectricCurrent> m1 = Amount.valueOf("234 mA").to(MICRO(AMPERE));

// m0 =    100 lb
// m1 = 234000 uA

Unit<Mass> u  = m0.getUnit();
Dimension d   = u.getDimension();

\end{minted}
\caption{Example for JScience from the official documentation \citep{Dautelle11}. Usage is straightforward and unit information is still available at runtime.}
\label{code:jscience_example}
\end{figure}

Unit safety is enforced both by the type system at compile time (Measures are generic classes with their units as type parameters) and comparison functions at run time (\emph{equals} only returns true if both the value and the interval match, etc.).

Unfortunately, the performance hit due to the wrapper classes is quite severe - I experienced a slowdown of around 80 on my machine in a simple benchmark, compared to normal primitives (\emph{int} and \emph{double}) (see Figure \ref{bench:jscience}).

At the moment, Units of Measurement Systems in Java are only practicable in systems that are not performance critical. Alas, many systems that would benefit most are performance critical - computer game engines, high frequency trading, etc. Therefore, Units of Measurements remain a niche application in Java.

\begin{figure}
\begin{tabular}{lrrr}
method          & int    & double  & JScience \\
\midrule
addition        & 1.0 ns &  1.8 ns    &   149.5 ns \\
multiplication  & 1.1 ns &  1.9 ns    &   162.3 ns
\end{tabular}
\caption{A simple benchmark of JScience compared to primitives data types. JScience is at least 80 times slower on average.}
\label{bench:jscience}
\end{figure}


\subsection{Python - units}

Python is a dynamic language, so the only way to make a system of measurements work is to create a dynamic system that relies on tagged numbers. That's exactly what \emph{units} \citep{Donohue12} does.

\begin{figure}
\begin{minted}{python}
metre, second = unit('m'), unit('s')                   # define units
print(metre(10) / second(2))                           # 5 m / s
newton = named_unit('N', ['kg', 'm'], ['s', 's'], 1)   # 1 N = 1 kg*m/s^2
units.predefined.define_units()                        # SI units and more
\end{minted}
\caption{\emph{units} makes it very simple to define custom units and to add conversions to existing units, while also including all standard units for immediate use. Calculation happens just like with primitives, thanks to operator overloading.}
\label{code:python_units}
\end{figure}



\begin{figure}
\begin{tabular}{lrrr}
method          & int    & double  & units \\
\midrule
addition        & 151 ns &  164 ns    &   4136 ns \\
multiplication  & 159 ns &  165 ns    &   22.352 ns
\end{tabular}
\caption{Even though Python is an interpreted language, there is a large difference between primitive numbers, and those provided by the \emph{units} library. The slowdown is especially severe for the multiplication as a new unit has to be generated for the result.}
\label{bench:python_units}
\end{figure}


\section{Static Systems}

\subsection{F\#}
\citep{Kennedy08:1}
\citep{Kennedy08:2}
\citep{Kennedy08:3}
\citep{Kennedy08:4}

\subsection{C++ - Boost.Units}
\citep{Schabel10}

\subsection{Haskell - Dimensional}
\citep{Buckwalter06}

\subsection{Scala}
\citep{Hans12}
\citep{Nygard09}
\citep{McBeath08}

\singlespacing
\bibliographystyle{dinat}
\bibliography{thesis}{}
\addcontentsline{toc}{chapter}{A \;References}

\chapter*{}
\onehalfspacing
Ich erkläre, dass ich diese Fachbereichsarbeit ausschließlich selbst und ohne Gebrauch unerlaubter Hilfsmittel oder Hilfen verfasst habe.



\end{document}
